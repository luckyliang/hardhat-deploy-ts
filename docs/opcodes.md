## 操作指令

内存中0x40储存的是空闲内存指针

空闲内存指针的目的只是指向内存中的一个空闲槽，每当内存使用这个槽时，指针就会改变到另一个空闲地址。让我们继续往下看。

- PUSH：入栈操作

- POP：出栈

- MSTORE：需要两个参数（offset、value），将第二个出栈的数据储存在第一个出栈的位置处

  ```assembly
  000 PUSH1 80
  000 PUSH1 40
  MSTORE
  ```

  memory

  ```solidity
  000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080	
  ```

  EVM将**0x80**存储在内存为**0x40**的位置种，由于内存中的每一个插槽都是32个字节的长度（使用小端序的十六进制0x20），因此插槽40的内存位于0x40和**0x40+0x20=0x60**之间（我们将其记为内存**[0x40:0x60]**）

  这就是为什么0x80在最后（0x5f位置）。

  内存中的 "0x40 "槽在EVM中被命名为**空闲内存指针**，当需要内存时，它被用来分配内存的新槽。

  **重要的是：注意在一条指令之后，堆栈中所有需要的参数都会从堆栈中清除，并被返回值所取代。**

  由于MSTORE在堆栈中占用了2个参数，在MSTORE指令完成后，这2个参数会从堆栈中删除。

- CALLVALUE

  **CALLVALUE**指令把**msg.value**（发送给智能合约的以太币）放在堆栈中。

  ```assembly
  005 CALLVALUE |msg.value|
  ```

  如果没有向智能合约发送任何以太币，堆栈中的值是：`| 0x00 |`

- **DUP1**（duplicate复制）

  复制栈顶数据，压入栈，注意还有DUP2, DUP3...DUPn(直到DUP16)，它们将第n个值(Stack n-1)推到堆栈中。

- **SWAP1**

  交换栈中0和1位置中的位置

  ```
  0: 0x0000000000000000000000000000000000000000000000000000000000000009
  1: 0x0000000000000000000000000000000000000000000000000000000000000000
  2: 0x0000000000000000000000000000000000000000000000000000000000000009
  ```

  SWAP1后

  ```
  0: 0x0000000000000000000000000000000000000000000000000000000000000000
  1: 0x0000000000000000000000000000000000000000000000000000000000000009
  2: 0x0000000000000000000000000000000000000000000000000000000000000009
  ```

  SWAP(n) 交换栈中0和n位置的值

  如SWAP2 交换位于stack(0)和stack(2)中的值

- **ISZERO**

  判断栈顶值是否等于0，如果是，则把栈顶值改为1

- **JUMPI**（指令使用了两个栈中元素，执行后会删除两个栈元素）

  条件调转指令，如果stack（1）== 1， EVM直接进入字节数stack（0）所在的位置，

  如：stack（0）= 0x0f，(十进制15)，如果Stack（1）== 1，那么EVM直接跳转到第15个指令

  如果不是，EVM继续依次执行它的路径，

- **JUMPDEST**

  没有任何作用，他只是表示一条JUMP或JUMPI指令指向这里，如果EVM跳到一个没有标记为“JUMPDEST”的地址，他就会自动回退

- CALLDATASIZE

  EVM调用**CALLDATASIZE**，等于msg.data.size（以太坊交易中数据字段的大小）, (当一个函数被调用时没有参数msg.data.size = 4，这4个字节被称为函数 "签名")

- **LT**：小于，它比较堆栈上的两个值（如果**Stack(0) < Stack(1)**，那么我们写1，否则写0）。

- **CALLDATALOAD**：储存msg.data到栈（stack(0)）中

  接受1个参数Stack(0)作为偏移量，并将msg.data之后的在参数位置（这里是Stack(0)）的下一个32字节存储在堆栈中Stack(0)

  在此案例中，它存储msg.data的前32字节（因为Stack(0) = 0）。

- **SHR**：位移操作，接收两个参数（stack(0)）

- **EQ**：比较（**Stack(0)\**和\**Stack(1)**）。相等写入1否则写入0到栈中

- **SSTORE**：操作码将Stack(1)存储到Stack(0)槽中(储存在链中storage)（顾名思义）。(所以它使用了2个参数，因此在执行**SSTORE**的第21指令后，它们被从堆栈中移除了)

  ```
  0:0x0000000000000000000000000000000000000000000000000000000000000000
  1:0x0000000000000000000000000000000000000000000000000000000000000009
  ```

  内联汇编：

  ```
  sstore(0x00,0x09)
  ```

  Remix 控制debug面板中Storage栏储存记录

  ```
  
  Storage[Completely Loaded]
  0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563:Object
  key:0x0000000000000000000000000000000000000000000000000000000000000000
  value:0x0000000000000000000000000000000000000000000000000000000000000009
  ```

  

- **RETURN**：停止代码的执行，并返回内存[Stack(0):Stack(0)+Stack(1)]，

  在部署合约过程中RETURN执行后会返回合约字节码，这是**[0x00:0x40]**位置储存的字节码。

  **返回的这个值是存储在区块链中的**

- **MLOAD**：从内存中加载Stack(0)位置的**值**到堆栈，在内联汇编中是**MLOAD(0x40)**。因此80被推送到堆栈。(因为80在之前被存储在内存0x40处)

- **SLOAD**：在Stack(0)槽中加载Storage值（备注：存储槽没有写入过，默认都是 0）

- **CODECOPY**：是一个特殊的操作码，它可以EVM内存中复制当前智能合约代码

  `CODECOPY`指令的参数(destOffset,offset,size)

  \- Stack(0) 复制代码到哪个内存位置。
  \- Stack(1) 开始复制代码时，在已执行的代码中的偏移量（从哪个位置开始复制）。
  \- Stack(2) 要复制多少字节的代码？

  它需要3个参数：

  - 第一个是Stack(0)，指令复制当前智能合约代码到EVM内存的Stack(0) 位置（这里Stack(0)=0），所以它将复制到内存的0x00槽。
  - 更确切地说，复制智能合约代码从**Stack(2)\**个字节到\**Stack(2)+Stack(1)\**个字节。
    看一下堆栈，这是位于\**0x22（=34的十进制）和（22+3f=61，即97的十进制）之间的代码**。

- **CODESIZE**：不从堆栈中获取任何参数，在堆栈中保存代码的大小，它是执行的代码的大小（因此这也是交易数据的大小，因为如前所述，要执行的代码位于交易数据中）

- **SUB**：执行Stack(0) - Stack(1)

  如堆栈中是

   `0xd8 | 0x98 | 0x80`

  执行SUB操作码后：

  `0x40 | 0x80`	

  0xd8 - 0x98 = 0x40

- **NOT**：反转stack(0)中所有的字节

  ```
  0:0x0000000000000000000000000000000000000000000000000000000000ffffff
  ```

  NOT

  ```
  0:0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000
  ```

- **AND**：与运算，  stack(0) 与 stack(1) 后值储存在 stack(0)中

  ```
  0:0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000
  1:0x0000000000000000000000000000000000000000000000000000000000000000
  ```

  AND运算后

  ```
  0:0x0000000000000000000000000000000000000000000000000000000000000000
  1:0x0000000000000000000000000000000000000000000000000000000000000000
  ```

- **OR**：或运算 0 OR x = x

- **SHL**：左移运算 << ， stack(1) 左移 stack(0)位

  ```
  0:0x00000000000000000000000000000000000000000000000000000000000000c8
  1:0x0000000000000000000000000000000000000000000000000000000000000001
  ```

  上面是将1左移动200位

  移动后将值储存在stack(0)位置处

  ```
  0:0x0000000000000100000000000000000000000000000000000000000000000000
  ```

  

- SHR： 右移运算 >> , stack(1) 右移 stack(0)位

- **STOP**：结束智能合约的执行